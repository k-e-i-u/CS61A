# 1 高质量编程的关键问题
- 高质量编程涉及多方面的知识，可以拿做机械、木工等场景类比：
	- 要理解业务的需求和问题，选择合适的编程工具。
	- 要理解业务的需求和问题，设计高效的算法代码。
	- 要理解系统设计的哲学和技法，构建、管理和优化大型复杂程序。
	- 要理解程序测试的哲学和技法，设计合适的测试用例，发现程序漏洞、提升程序稳定性。

## 1.1 选择编程工具
- 首先，编程工具要适配业务场景、性能需求、运维需求，应选取最适用的、而不是最先进的。
- 其次，在适用的选型清单中，要选取最主流的、用户社群活跃的，越多人用的工具越稳定，不选非主流的、小众的。
- 最后，主布更新迭代工具，大胆探索更先进的编程工具，若合适，大胆应用到生产环境。

## 1.2 业务理解&算法设计
### 1.2.1 业务理解
- 初步理解业务全过程，抽象业务环节，构建业务流程图，设计最初算法代码。
- 关注算法复杂度，优化算法低效环节。
- 寻找算法漏洞、编写测试用例、测试算法健壮性。

### 1.2.2 算法设计的核心
#### 1.2.2.1 迭代和递归
![[attachments/迭代和递归.png]]
- 迭代和递归的起源：
	- 迭代和递归是两种基础算法设计理论，均借鉴了逻辑学的理论。迭代借鉴数理逻辑的递归论、递归借鉴形式逻辑的归纳逻辑。

- 迭代、递归与解空间搜索：从本质角度考虑，迭代和递归均是“关于如何最优化搜索解空间的算法”。
	- “迭代-分治-组合”：设计迭代算法，强调迭代、分治和组合。即：
		- 将函数设计成可以直接或间接调用自身（迭代），并单纯地信任 **“小问题可以被函数自身调用（迭代）正确地解决”** （即a recursive leap of faith）。
		- 通过迭代开始阶段，按照不同的拆分条件判断、将大问题拆成多个小问题（分治），在解空间搜索角度看来，就是“按top-down顺序探索解空间”；
		- 通过迭代返回阶段，按照逻辑顺序、将小问题的答案计算出来并有序向上层返回（组合），就是“按bottom-up顺序组合最终解”。
	- “基例-循环-状态”：设计递归算法，强调基例、循环和状态。即：
		- 从最简单的情况（也即“基例”）出发，构造最终问题的解。
		- 构建最终解的过程中，使用循环的方式，探索解空间。
		- 探索解空间的过程中，维护和更新一个或多个状态变量，用于标记当前解空间的搜索进度，并判断当前循环的继续与否。

- 递归算法设计，常被用在：处理具有分治特性的数据结构、解决数学中的递归问题、解决具有分治特性的应用问题。
	- 图遍历、树遍历。
	- 阶乘计算、斐波那契数列、Number Partitions问题、Sum Digits问题。
	- 快速排序应用、N皇后问题、递归版动态规划(斐波那契、最长公共子序列、01背包、矩阵链乘法)。

- 迭代算法设计，常被用在：解决具有线性特性的应用问题、处理广度搜索相关的应用问题、处理性能受限的动态规划场景。
	- 选择排序、列表和计算。
	- BFS搜索、无权图最短路径、树的层序遍历、连通分量和岛屿计数问题、检测环和二分图。
	- 迭代版动态规划解最长公共子序列。

#### Mutual Recursion和Tree Recursion
![[Pasted image 20250514172042.png]]
- Mutual Recursion和Tree Recursion是递归的两种高级形式。
	- Normal Recursion：函数体每执行一次，有且仅有一次递归调用。如CASE FOUR：sum_digits。
	- Mutual Recursion：有两个函数互相进行递归调用。如CASE FIVE：is_even & is_odd。
	- Tree Recursion：函数体每执行一次，调用两次及以上的递归。如CASE ONE：count_partitions。

- Mutual Recursion：
	- pro:：可以应对更复杂的问题，因为mutual recursion的过程中，复杂的递归调用栈，可以存储更多的状态。
	- cons:：设计起来比基础递归复杂。

- Tree Recursion：
	- pro：针对更复杂的解空间搜索问题，因为每次可以执行多个递归，因此可以提高算法设计效率，降低算法的空间复杂度和设计难度。
	- cons：对性能需求更高、时间复杂度更高。
#### 1.2.2.1.1 递归算法样例
![[Pasted image 20250514152741.png|900]]

- 函数体的开头，应该先明确一个或多个base case，编写条件判断代码，用来判断和捕获最简单子问题。*在n!递归问题中，最简单子问题就是1的阶乘。*
- Base CASE之后，是一个或多个迭代调用(Recursive Calls)，迭代调用的传入参数应当体现具体的“分治”策略（即问题大拆小的策略）。*分治策略的优劣，决定算法设计的正确性和运行效率。*
- 迭代调用要按照逻辑顺序，有序组合起来。*组合的方式可以是简单相加（如CASE ONE 第52行），也可以是用list组合（如CASE TWO第81行），也可以是直接打印出来（如CASE THREE第133 134行）。*

CASE ONE：count_partition函数，计算给定n,m时，number partition一共有多少种。
![[Pasted image 20250514112951.png|600]]

CASE TWO：fib_tree函数，生成给定n时的斐波那契数树。
![[Pasted image 20250514113555.png|500]]

CASE THREE: partition_tree函数，生成给定n,m时，number partition的所有可能结果树。
![[Pasted image 20250514113817.png|500]]

CASE FOUR：sum_digits，将一个正整数n的所有数字相加的和。
![[Pasted image 20250514163304.png|700]]

CASE FIVE: is_even, is_odd，判断一个正整数N是否是EVEN的。 
![[Pasted image 20250514163425.png]]

#### 1.2.2.1.1 迭代算法样例
![[迭代代码结构.png|700]]

- 函数体的开头，创建多个用于维护状态的变量。
- 使用for或者while循环，迭代搜索解空间、构建最终解。
- 在for和while循环内，更新维护状态变量。

CASE ONE: fact_iter，通过迭代的方式，计算n!的值。
![[Pasted image 20250520094638.png|600]]

## 1.3 系统设计


### 抽象和组合


抽象和组合是开发管理大型程序的两种核心手段，





## 1.4 程序测试



# 2 现代编程语言的关键问题

## 2.1 现代编程语言的关键元素


## 2.2 编译器工作的关键原理



# 3 算法与数据结构的核心知识

## 3.1 现代编程语言的基础数据类型


## 3.2 定义数据抽象的核心步骤


