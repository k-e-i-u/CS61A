---
number headings: first-level 1, max 6, 1.1
---
# 1 note
**本课程关注的重点内容：复杂度控制方法论(抽象编程和组合编程)、编程范式programming paradigms、解释器的运行原理。**


---

## 1.1 编程范式
**编程范式（Programming Paradigm）是指程序员在设计和编写程序时，采用的一种基本思维方式或方法论**
1. 不同编程范式，均提供了不同的程序设计哲学。从实践角度考虑，可以理解为：*不同编程范式，定义了如何处理数据、组织代码、分解问题的方法。*
2. 不同编程范式，有不同特长和适用场景。
	- 命令式编程：需要精确控制底层操作的场景，如系统编程、嵌入式开发。
	- 面向对象编程：大型系统开发、需要建模复杂关系的场景（如GUI开发、游戏开发）。
	- 函数式编程：并发/并行处理、数学建模、数据处理。
	- 事件驱动编程：实时系统，包括：GUI应用、Web开发、工业系统等。
	- 并发编程：利用多线程模型，适合高性能计算、网络服务、分布式系统。
	- 声明式编程：适合只需要提供指令，不需要描述具体执行步骤就可获得结果的场景，如，数据库查询、UI描述、配置管理。
	- 元编程：适合框架开发、自动化代码生成。

---

### 1.1.1 各类编程范式概述
**命令式编程（Imperative Programming）**
- **核心思想**：
	-  以“如何做”为核心，程序员明确指定计算机执行的每一步操作。
- **特点**：
	- 使用变量、赋值语句、控制结构（如循环、条件语句）。
    - 程序员需要详细控制程序状态的变化（通过变量赋值、循环、条件语句等）。
	- 直接操作内存和状态（如变量赋值）。
- **示例语言**：
	- C、Fortran。
- **适用场景**：
	- 需要精确控制底层操作的场景，如系统编程、嵌入式开发。
- **优点**：直观，易于理解，适合低层次控制。
- **缺点**：代码复杂时容易出现状态管理混乱，维护性较差。
- **例子**：

     ```c
     int sum = 0;
     for (int i = 1; i <= 10; i++) {
         sum += i;
     }
     ```

---

 **面向对象编程（Object-Oriented Programming, OOP）**
- **核心思想**：
	- 以“是什么”为核心，将问题分解和抽象为对象（数据和行为的封装）。将程序组织为对象的集合，并通过对象之间的交互（方法调用、继承、封装）解决问题。
- **特点**：
	- 对象包含数据（属性）和操作数据的方法（行为）。同时数据（属性）和方法（行为）绑定，对象通过方法交互。
	- 面向对象编程，需要遵守和强调：封装、继承、多态。模仿现实世界的实体关系。
- **示例语言**：
	- Java、C++、Python、C#。
- **适用场景**：
	- 适合于需要建模现实世界实体（如用户、订单、车辆）的场景，进行大型、复杂系统开发，如GUI框架、游戏开发、企业级应用。
- **优点**：代码模块化，可重用性高，适合团队协作和长期维护。
- **缺点**：设计复杂系统时可能引入过多抽象，导致性能开销或过度设计。
- **例子**：

     ```java
     class Dog {
         String name;
         void bark() {
             System.out.println(name + " says Woof!");
         }
     }
     Dog myDog = new Dog();
     myDog.name = "Buddy";
     myDog.bark();
     ```

---

**函数式编程（Functional Programming, FP）**
   - **核心思想**：
	   - 以“计算结果”为核心，将问题抽象为数学函数的组合，关注输入到输出的映射。思维方式类似于“数学推导”，而非“如何执行”。
   - **特点**：
     - 函数是一等公民（First-Class Citizen），可作为参数、返回值或存储在变量中。
     - 使用纯函数（无副作用，相同输入总产生相同输出）。
     - 避免显式的状态管理和循环，倾向于递归算法设计哲学，在调用栈中隐式保管状态。
     - 强调不可变数据（Immutable Data）和无副作用（Side-Effect Free）的函数。因此倡导使用，不可变数据、函数组合、高阶函数（如map、reduce）。
   - **示例语言**：Haskell、Scala、Erlang、JavaScript（支持函数式风格）。
   - **适用场景**：并发/并行处理、数学建模、数据处理。
   - **优点**：代码简洁，易于测试和并行化，副作用少。
   - **缺点**：学习曲线陡峭，性能可能不如命令式编程优化。
   - **例子**：
     ```haskell
     let sum = foldr (+) 0 [1..10]
     ```

---

**事件驱动编程（Event-Driven Programming）**
   - **核心思想**：
	   - 以“响应事件”为核心，程序员为主思考如何定义事件及其处理逻辑，程序的执行由事件触发。（如用户输入、消息、传感器信号）。
   - **特点**：
     - 思维方式类似于“等待和响应”，强调异步和交互。
     - 使用事件循环（Event Loop）和回调函数，监听和处理事件。
     - 常与观察者模式结合使用。
   - **示例语言**：
	   - JavaScript、C#（用于GUI开发）、Python（使用事件库）。
   - **适用场景**：
	   - 实时系统，包括：GUI应用、Web开发、工业系统等。
   - **优点**：适合异步和交互式应用，响应性强。
   - **缺点**：回调地狱（callback hell）可能导致代码复杂，调试困难。 
   - **例子**：
     ```javascript
     document.getElementById("myButton").addEventListener("click", function() {
         alert("Button clicked!");
     });
     ```

---

**并发编程（Concurrent Programming）**
   - **核心思想**：
	   - 基于线程模型编程，以支持程序并发（即：程序中，多个任务同时执行）。
   - **特点**：
     - 强调任务的并行或异步执行，管理共享资源和同步。
     - 基于线程模型，实现并发编程。（如：多线程、协程、Actor模型）。
     - 并发编程，可以结合其他编程范式，共同使用（如：OOP、FP）。
   - **示例语言**：
	   - Go、Erlang、Rust、Java（并发库）。
   - **适用场景**：
	   - 高性能计算、网络服务、分布式系统。
   - **例子**：
     ```go
     func main() {
         go func() {
             fmt.Println("Running in a goroutine")
         }()
         time.Sleep(time.Second)
     }
     ```

---

**声明式编程（Declarative  Programming）**
   - **核心思想**：
	   - 描述“要什么”（目标结果），而非描述“怎么做”（具体步骤），由系统决定执行方式。
   - **特点**：
     - 程序员只需定义规则或目标，就可以获得结果。
     - 包括子范式，如：逻辑式编程、查询语言。
   - **示例语言**：
	   - SQL、HTML、CSS、Prolog。
   - **适用场景**：
	   - 数据库查询、UI描述、配置管理。
   - **例子**：
     ```sql
     SELECT name FROM users WHERE age > 18;
     ```

---

**元编程（Meta  programming）**
   - **核心思想**：
	   - 编写能够生成或操作自身或其他程序的代码。
   - **特点**：
     - 通过反射、宏、代码生成等机制实现元编程。
     - 提高代码复用性和灵活性，但可能增加复杂度。
   - **示例语言**：
	   - Lisp、Ruby、C++（模板元编程）。
   - **适用场景**：
	   - 框架开发、自动化代码生成。
   - **例子**：
     ```ruby
     class MyClass
       define_method :say_hello do
         puts "Hello!"
       end
     end
     MyClass.new.say_hello
     ```

---

 **逻辑式编程（Logic Programming）**
   - **核心思想**：
	   - 程序通过描述问题的事实和规则（逻辑关系）来表达，计算通过推理和查询完成。
   - **特点**：
     - 使用逻辑语句（如谓词）定义问题，交给推理引擎求解。
     - 不关注具体的执行步骤，只关注“是什么”而非“怎么做”。
     - 常用于知识表示和自动推理。
   - **示例语言**：
	   - Prolog、Datalog。
   - **适用场景**：
	   - 人工智能、专家系统、自然语言处理。
   - **优点**：适合声明式问题，推理能力强。
   - **缺点**：适用范围较窄，性能较低，调试复杂。
   - **例子**：
     ```prolog
     parent(john, mary).
     ancestor(X, Y) :- parent(X, Y).
     ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
     ```

---

### 1.1.2 不同编程范式处理数据的方式
**不同编程范式在处理和对待数据的方式上有着本质的区别，这些区别源于它们的核心哲学和思维方式。**
1. 核心区别
	1. **命令式**直接操作可变数据，强调控制流程。
	2. **面向对象**将数据封装为对象，强调实体关系。
	3. **函数式**视数据为不可变值，强调函数转换。
	4. **逻辑式**将数据作为逻辑关系，依赖推理。
	5. **事件驱动**以事件为核心，数据随事件动态更新。

---

**命令式编程（Imperative Programming）**
- **数据表示**：
  - 数据通常以**变量**或**数据结构**（如数组、结构体）的形式存储在内存中。
  - 数据被视为可变的存储单元，程序员直接操作内存地址或变量内容。
  - 示例：C语言中的`int x = 5`表示一个可变整数变量。
- **数据操作**：
  - 通过显式的**赋值语句**、**循环**和**条件语句**直接修改数据。
  - 程序员手动控制数据的读写和更新，例如`x = x + 1`直接改变变量`x`的值。
  - 数据操作通常是**顺序执行**，强调“一步步”改变状态以达到目标。
- **数据状态管理**：
  - 数据状态是**可变的**，程序员需要跟踪和管理变量的状态变化。
  - 状态管理依赖程序员的逻辑控制，容易因状态复杂而导致错误（如未初始化的变量）。
  - 示例：用循环累加数组元素，需手动更新累加器变量。
- **对待数据的哲学**：
  - 数据是**可变**的，程序员关注如何通过修改数据来实现计算。
  - 强调对数据的**直接控制**，与底层硬件模型（如寄存器、内存）一致。
- **典型场景**：
  - 适合需要精确控制数据操作的场景，如嵌入式系统、性能优化的算法。
  - 示例：用C语言实现矩阵运算，数据存储在数组中，通过循环直接修改。

---

**面向对象编程（Object-Oriented Programming, OOP）**
- **数据表示**：
  - 数据被封装在**对象**中，对象是数据（属性）和行为（方法）的结合。
  - 数据以**类的实例**形式存在，类定义了数据的结构和操作规则。
  - 示例：Java中的`class Person { String name; int age; }`将`name`和`age`封装为对象的属性。
- **数据操作**：
  - 数据通过对象的**方法**（函数）进行操作，方法定义了数据的合法修改方式。
  - 强调**封装**，通过访问控制（如`private`）限制对数据的直接访问，外部只能通过公共方法（如`setName()`）修改数据。
  - 示例：调用`person.setAge(30)`修改对象的`age`属性。
- **数据状态管理**：
  - 数据状态存储在对象的属性中，状态变化通过方法调用控制。
  - 支持**继承**和**多态**，允许不同对象共享数据结构或行为。
  - 状态管理依赖对象的生命周期，可能涉及复杂的对象关系（如继承链）。
- **对待数据的哲学**：
  - 数据是**对象的核心**，与行为紧密绑定，模仿现实世界的实体。
  - 强调**数据封装**和**抽象**，通过对象交互实现问题解决。
- **典型场景**：
  - 适合建模复杂实体关系，如GUI系统、游戏开发（角色、场景）。
  - 示例：银行系统中，`Account`对象封装余额（数据）并提供`deposit()`方法（操作）。

---

**函数式编程（Functional Programming）**
- **数据表示**：
  - 数据被视为**不可变**的值或数据结构，强调**不可变性**（immutability）。
  - 数据通常以**值**或**表达式**的形式存在，而不是可变的变量。
  - 示例：Haskell中的`let x = 5`定义不可变的绑定，`x`不能被重新赋值。
- **数据操作**：
  - 数据通过**纯函数**（无副作用，相同输入产生相同输出）进行转换。
  - 操作以**函数组合**和**高阶函数**（如`map`、`filter`、`reduce`）为核心，生成新的数据而非修改原有数据。
  - 示例：用`map (+1) [1,2,3]`将列表`[1,2,3]`转换为`[2,3,4]`，原列表不变。
- **数据状态管理**：
  - 避免显式的状态管理，数据状态通过**函数调用链**或**递归**隐式传递。
  - 不可变性保证数据一致性，减少状态相关的错误。
  - 示例：递归计算斐波那契数列，函数调用生成新值而非修改变量。
- **对待数据的哲学**：
  - 数据是**不可变的数学值**，程序通过函数变换从输入映射到输出。
  - 强调**声明式**编程，关注“做什么”而非“怎么做”。
- **典型场景**：
  - 适合并发、并行计算、数据流处理，如大数据分析（Spark）、数学建模。
  - 示例：用Scala处理数据流，`list.map(x => x * 2).filter(x => x > 10)`转换数据。

---

 **逻辑式编程（Logic Programming）**
- **数据表示**：
  - 数据以**事实**（facts）和**规则**（rules）的形式表示，通常存储在**知识库**中。
  - 数据描述逻辑关系，而非具体的数值或对象。
  - 示例：Prolog中`parent(john, mary).`表示“John是Mary的父母”这一事实。
- **数据操作**：
  - 数据通过**查询**（queries）操作，程序员定义逻辑关系，推理引擎自动推导结果。
  - 操作基于**逻辑推理**（如 unification 和 backtracking），无需显式指定执行步骤。
  - 示例：查询`?- parent(X, mary).`查找Mary的父母。
- **数据状态管理**：
  - 没有显式的状态管理，数据状态由**知识库**和**推理过程**维护。
  - 程序员无需关心数据如何变化，推理引擎自动管理。
- **对待数据的哲学**：
  - 数据是**逻辑关系**的集合，程序通过推理从关系中提取答案。
  - 强调**声明式**，程序员描述“是什么”而非“如何做”。
- **典型场景**：
  - 适合需要逻辑推理的场景，如人工智能、专家系统、自然语言处理。
  - 示例：Prolog实现家族关系查询或约束满足问题。

---

 **事件驱动编程（Event-Driven Programming）**
- **数据表示**：
  - 数据通常与**事件**绑定，表示触发事件的状态或上下文（如用户输入、传感器数据）。
  - 数据可以是临时的事件对象，也可以是持久化的状态（如UI组件的状态）。
  - 示例：JavaScript中`event`对象包含用户点击的坐标、按键等信息。
- **数据操作**：
  - 数据通过**事件处理器**或**回调函数**处理，响应特定事件（如点击、消息到达）。
  - 操作通常是**异步**的，程序员定义事件触发后的数据处理逻辑。
  - 示例：`button.onclick = () => updateCounter(counter + 1)`响应点击事件更新计数器。
- **数据状态管理**：
  - 数据状态由**事件循环**和**状态容器**（如UI状态、数据库）管理。
  - 状态变化由事件触发，程序员需确保事件处理逻辑一致性。
- **对待数据的哲学**：
  - 数据是**事件驱动的动态状态**，程序通过响应事件更新数据。
  - 强调**异步性**和**响应性**，适合交互式系统。
- **典型场景**：
  - 适合用户界面、实时系统、物联网，如Web前端、服务器请求处理。
  - 示例：JavaScript处理用户点击事件更新页面内容。

---

**不同编程范式，数据处理哲学的，总结与对比**

| 编程范式        | 数据表示                     | 数据操作                     | 数据状态管理                 | 典型场景                           |
|-----------------|-----------------------------|-----------------------------|-----------------------------|-----------------------------------|
| **命令式**      | 可变变量/数据结构            | 赋值、循环、条件语句          | 手动跟踪状态变化             | 嵌入式、算法实现                  |
| **面向对象**    | 对象（数据+行为）            | 方法调用、封装              | 对象生命周期管理             | 复杂系统建模、GUI开发            |
| **函数式**      | 不可变值                    | 纯函数、函数组合            | 无显式状态，函数调用传递      | 并发、数据流处理、数学建模       |
| **逻辑式**      | 事实和规则（知识库）         | 逻辑查询、推理              | 推理引擎管理                 | AI、专家系统、约束满足           |
| **事件驱动**    | 事件对象/状态容器           | 事件处理器、回调函数         | 事件循环管理                 | UI、实时系统、物联网             |

编程范式通过其独特的**控制逻辑**、**问题分解方式**和**代码组织方式**，深刻影响程序员如何设计和实现代码。以下详细分析主流编程范式（命令式、面向对象、函数式、逻辑式、事件驱动）在这三个方面的具体表现，并结合实际场景和示例进行说明。

---

### 1.1.3 不同编程范式的控制逻辑、问题分解方式、代码组织逻辑
**命令式编程（Imperative Programming）**
- **控制逻辑**：
  - **特点**：强调**顺序执行**，程序员通过明确的指令（如赋值、循环、条件语句）控制程序的执行流程。
  - **实现方式**：
    - 程序以**步骤序列**形式执行，程序员指定每一步的操作。
    - 使用`if-else`、`for`、`while`等结构控制流程，状态通过变量显式更新。
    - 示例：C语言中计算数组和的代码：
      ```c
      int sum = 0;
      for (int i = 0; i < n; i++) {
          sum += array[i];
      }
      ```
      这里，程序员通过循环明确控制如何遍历和累加。
  - **思维方式**：程序员像“导演”，逐条指导计算机完成任务，关注“如何做”。

- **问题分解**：
  - **特点**：将问题分解为**一系列顺序步骤**，每个步骤解决一个子任务。
  - **实现方式**：
    - 问题被拆分为小的、具体的操作（如初始化、计算、更新结果）。
    - 程序员需要手动管理状态变化，确保每一步正确衔接。
    - 示例：实现冒泡排序时，问题分解为“比较相邻元素”、“交换元素”、“重复直到有序”。
  - **适用场景**：适合需要精确控制执行顺序的任务，如硬件驱动、嵌入式系统。

- **代码组织**：
  - **特点**：代码以**过程**或**函数**为单位组织，强调逻辑的线性结构。
  - **实现方式**：
    - 使用函数或子程序封装可重用逻辑，但函数通常直接操作全局或共享状态。
    - 代码结构简单，模块化程度较低，依赖程序员手动组织。
    - 示例：C程序中，函数如`compute_sum(array, n)`封装数组求和逻辑，但状态（如`sum`）由程序员显式管理。
  - **优缺点**：
    - **优点**：直观，接近底层硬件逻辑，适合性能优化。
    - **缺点**：复杂问题可能导致代码冗长，状态管理混乱，维护性较差。

---

**面向对象编程（Object-Oriented Programming, OOP）**
- **控制逻辑**：
  - **特点**：通过**对象交互**控制程序流程，执行逻辑封装在对象的方法中。
  - **实现方式**：
    - 程序通过调用对象的方法（如`obj.method()`）实现功能，方法内部定义执行逻辑。
    - 控制流程基于**消息传递**（对象间的调用），支持**多态**（不同对象对同一方法的不同实现）。
    - 示例：Java中模拟银行账户：
      ```java
      class Account {
          private double balance;
          public void deposit(double amount) {
              balance += amount;
          }
      }
      Account acc = new Account();
      acc.deposit(100.0);
      ```
      这里，`deposit`方法封装了状态更新逻辑，控制通过方法调用实现。
  - **思维方式**：程序员像“建筑师”，设计对象及其交互，关注“是什么”。

- **问题分解**：
  - **特点**：将问题分解为**实体（对象）**，每个对象封装数据和行为。
  - **实现方式**：
    - 问题被建 Halifax
System: ized为类、对象、方法等，实体对应现实世界中的对象（如“账户”、“用户”）。
    - 通过**继承**和**组合**构建对象间的关系，分解复杂系统。
    - 示例：银行系统分解为`Account`、`User`、`Transaction`等类，每个类负责一部分功能。
  - **适用场景**：适合建模复杂实体关系，如GUI框架、游戏开发。

- **代码组织**：
  - **特点**：代码以**类和对象**为核心，强调**封装**、**继承**和**多态**。
  - **实现方式**：
    - 类定义数据和行为的模板，对象是类的实例。
    - 代码通过模块化类和包（package）组织，支持大型项目开发。
    - 示例：Java的包结构将相关类组织在一起，`com.example.banking`包含银行相关类。
  - **优缺点**：
    - **优点**：模块化强，可重用性高，适合团队协作和长期维护。
    - **缺点**：可能引入过度抽象，增加设计复杂性和性能开销。

---

**函数式编程（Functional Programming）**

- **控制逻辑**：
  - **特点**：强调**无状态转换**，通过函数组合和数据流控制程序执行。
  - **实现方式**：
    - 使用**纯函数**（无副作用）和**高阶函数**（如`map`、`reduce`）实现逻辑。
    - 避免显式状态改变，控制逻辑通过函数调用链或递归传递。
    - 示例：Haskell中列表处理：
      ```haskell
      sumList = foldr (+) 0
      result = sumList [1, 2, 3] -- 输出6
      ```
      这里，`foldr`通过函数组合完成累加，无需显式循环。
  - **思维方式**：程序员像“数学家”，关注输入到输出的映射，声明“做什么”。

- **问题分解**：
  - **特点**：将问题分解为**函数调用**，每个函数解决一个子问题。
  - **实现方式**：
    - 使用**分治法**，将大问题分解为小问题，通过函数组合解决。
    - 强调**递归**和**惰性求值**，避免中间状态存储。
    - 示例：快速排序通过递归分解为“分区”和“子问题排序”。
  - **适用场景**：适合并发、数据流处理、数学计算。

- **代码组织**：
  - **特点**：代码以**函数**为核心，强调简洁性和组合性。
  - **实现方式**：
    - 函数是独立、可重用的单元，通过组合（如管道操作）构建复杂逻辑。
    - 模块化通过函数库或模块实现，代码通常短小精悍。
    - 示例：JavaScript的函数式风格：
      ```javascript
      const result = [1, 2, 3].map(x => x * 2).reduce((a, b) => a + b);
      ```
  - **优缺点**：
    - **优点**：代码简洁，易于测试和并行化，副作用少。
    - **缺点**：学习曲线陡峭，性能可能不如命令式优化。

---

**逻辑式编程（Logic Programming）**

- **控制逻辑**：
  - **特点**：通过**逻辑推理**控制程序，执行流程由推理引擎自动管理。
  - **实现方式**：
    - 程序员定义事实和规则，推理引擎通过**unification**和**回溯**找到解。
    - 没有显式的控制语句，程序员只需声明逻辑关系。
    - 示例：Prolog中：
      ```prolog
      parent(john, mary).
      parent(mary, bob).
      ancestor(X, Y) :- parent(X, Y).
      ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
      ?- ancestor(john, bob).
      ```
      推理引擎自动推导出`true`，无需指定执行步骤。
  - **思维方式**：程序员像“逻辑学家”，描述关系，依赖系统推理。

- **问题分解**：
  - **特点**：将问题分解为**事实**和**规则**，通过查询解决。
  - **实现方式**：
    - 问题被建模为逻辑关系，子问题通过规则递归定义。
    - 示例：家族关系问题分解为“父母”事实和“祖先”规则。
  - **适用场景**：适合人工智能、知识库查询、约束满足问题。

- **代码组织**：
  - **特点**：代码以**知识库**形式组织，分为事实、规则和查询。
  - **实现方式**：
    - 事实和规则存储在数据库中，查询驱动执行。
    - 模块化通过逻辑模块或文件实现，代码高度声明式。
    - 示例：Prolog文件中，家族关系规则集中存储，查询独立调用。
  - **优缺点**：
    - **优点**：声明式，推理能力强，适合复杂逻辑。
    - **缺点**：性能较低，调试困难，适用范围有限。

---

**事件驱动编程（Event-Driven Programming）**

- **控制逻辑**：
  - **特点**：通过**事件触发**控制程序，执行逻辑由事件循环管理。
  - **实现方式**：
    - 程序等待事件（如用户输入、定时器），调用相应的事件处理器。
    - 使用**回调函数**、**异步/等待机制**（如`async/await`）处理事件。
    - 示例：JavaScript中：
      ```javascript
      button.addEventListener('click', () => {
          console.log('Button clicked!');
      });
      ```
      点击事件触发回调函数，控制逻辑由事件驱动。
  - **思维方式**：程序员像“观察者”，设计事件响应逻辑，关注“何时做”。

- **问题分解**：
  - **特点**：将问题分解为**事件**和**处理逻辑**。
  - **实现方式**：
    - 每个事件对应一个独立的任务，处理逻辑封装在回调或处理器中。
    - 示例：Web页面分解为“点击按钮”、“输入文本”等事件，每个事件有独立逻辑。
  - **适用场景**：适合交互式应用、实时系统、物联网。

- **代码组织**：
  - **特点**：代码围绕**事件处理器**和**事件循环**组织，强调异步性。
  - **实现方式**：
    - 处理器函数独立定义，事件循环协调执行。
    - 模块化通过事件类型或模块（如Node.js的事件发射器）实现。
    - 示例：Node.js中：
      ```javascript
      const server = http.createServer((req, res) => {
          res.write('Hello, World!');
          res.end();
      });
      ```
      服务器响应HTTP请求事件，代码按事件组织。
  - **优缺点**：
    - **优点**：适合异步和交互式场景，响应性强。
    - **缺点**：回调地狱可能导致代码复杂，异步调试困难。

---

**总结与对比**

| 编程范式        | 控制逻辑                     | 问题分解                     | 代码组织                     |
|-----------------|-----------------------------|-----------------------------|-----------------------------|
| **命令式**      | 顺序执行，显式控制           | 顺序步骤                   | 函数/过程，线性结构          |
| **面向对象**    | 对象交互，方法调用           | 实体（类/对象）             | 类、包，模块化              |
| **函数式**      | 函数组合，无状态转换         | 函数调用，分治法            | 函数、模块，组合式          |
| **逻辑式**      | 逻辑推理，引擎驱动           | 事实和规则                 | 知识库，声明式              |
| **事件驱动**    | 事件触发，异步处理           | 事件和处理器               | 事件处理器，异步模块        |

**核心区别**
- **命令式**：控制逻辑显式，分解为步骤，代码线性。
- **面向对象**：通过对象交互控制，分解为实体，代码模块化。
- **函数式**：通过函数组合控制，分解为函数，代码简洁组合。
- **逻辑式**：依赖推理引擎，分解为逻辑关系，代码声明式。
- **事件驱动**：事件触发控制，分解为事件处理，代码异步模块化。

**选择依据**
- **控制逻辑**：需要精确顺序控制选命令式，异步响应选事件驱动，数学转换选函数式。
- **问题分解**：实体建模选面向对象，分治选函数式，逻辑推理选逻辑式。
- **代码组织**：大型项目选面向对象，简洁逻辑选函数式，交互系统选事件驱动。

---

## 1.2 解释器的简单原理 Interpreter
**解释器的核心作用是：分析和解释程序代码，在计算机上运行程序，并负责在内存中维护程序运行环境。**
1. 运行环境、帧、名字、值。
2. 表达式、声明、函数定义。

---

**运行环境 environment：一块由解释器向操作系统申请开辟的内存块，内部维护多种组成运行环境的成员（帧 frame、名字 name、值 value）。**
- 帧 frame：
	- 更小地一块内存区域，用于存储和维持"名字-值"绑定（name-value bindings)。
	- 每个frame之间，名字相对隔离，可在不同frame上存储相同的名字；相同frame内部，各种名字有且仅有一个，否则会覆盖旧有名字绑定。
	- 每个运行中的程序，有且只有一个global frame，其对应该程序初始运行时的入口函数。
	- 每当新的函数被调用，必须创建一个全新的local frame，用于存储函数运行期间的所有"名字-值"绑定（name-value bindings)。
	- 每当新的变量、数据结构、函数、对象被创建，必须在当前frame，记录新的"名字-值"绑定（name-value bindings)。
	- 具有自动内存回收的编程语言(java等)，将会自动回收长期未使用的"名字-值"绑定。反之其他类型编程语言则不会回(c等)。
- 名字 name：
	- 一个标识符identifier，通常是一个字符串，如hello_world、HelloWorld、helloWord等。
	- 名字name，是编程中最简单的抽象方法
	- 名字的使用，应遵循当前公司、组织机构的Coding Style，常见的有：google style, [GoatStyles](https://styles.goatbytes.io/) 等。
- 值 value：
	- 被当前编程语言、以及计算机操作系统所允许的、可以被用于计算的值，包括但不限于 int, float, string, array, dict, function, object等等。

---

### 1.2.1 表达式描述计算过程，一个合规的表达式，都能够计算出一个值。
- 表达式 expression：
	- 表达式可以分成三类：
		- 基本表达式 primitive expressions：表示各种值，包括但不限于int、float、bool、string、list、tuple等各种类型对应的值。
		- 算术表达式 arithmetic expressions：表示各种数学计算。
		- 函数调用表达式  function call expressions：即函数调用，常使用“Operator(Operand, Operand, ...)”的形式。
	- 表达式的计算求值：
		- 基本表达式，通常自身即代表着值，例如，3的值就是3。
		- [[#算术表达式的求值过程|算术表达式，通常需要结合"二叉树"、"栈"等数据结构，进行求值。]]同时对于变量名字，需要在environment中，按frame栈，顺序查找"名字-值绑定"。
		- 

```python
# 常见的基本表达式类型：
3 #整数
3.14  #浮点数
32.3e+18  #指数
9.322e-36j #复数
"Hello world" #字符串
True #布尔
["Hello", 1234, True]  #列表
("Hello", 1234, True)  #元组
{'Google', 'Facebook'}  #集合

# 常见的算术表达式类型：
18 + 69
6 / 23
5 * 3.14
101 % 2

# 函数调用表达式
max(2, 3)
max(min(pow(3,5), -4), min(1, -2))
```


---

### 1.2.2 声明描述待执行动作，最终将通过解释器执行动作。
**声明有多种类型，描述不同的动作。**
  - 引用声明 import statements
  - 赋值声明 assignment statements
  - 函数定义声明 function definition statements
  - 混合声明 compound statements


**引用声明 import statements**
```python
# python 引用声明的例子
from operator import mul
import pandas as pd
```

**赋值声明 assignment statements**
1. 按“left = right”格式书写的代码，最终将right的值，和left的名字绑定。

2. 赋值声明的执行规则：
	1. 例子： a, b = 2, 3 + 3
	2. 等号左边求值：2 求值得到 2， 3 + 3 求值得到6。
	3. 绑定到等号右边：a绑定2，b绑定6。
 
**函数定义声明 function definition statements**

**一个函数包括“函数签名”和“函数体”，是“抽象”技术，将计算过程，抽象成函数签名**。

- 函数定义声明的书写格式：
![函数定义声明|900](image-3.png)

- 函数定义声明的执行动作：创建函数签名、设置函数体、绑定函数签名和函数体。
![函数定义声明的执行动作|900](image-4.png)

- 用户自定义函数的生命周期：
![[Pasted image 20240430111937.png]]



**混合声明 compound statements ：混合声明是一个复杂的代码块，由一个或多个header，和1:1对应的statements suite组成，解释器根据header的结果、选择性执行对应statements suite。**

- 混合声明的结构：
![[Pasted image 20240430113344.png]]

- 常见的混合声明：
	- if-elif-else 声明。
	- while 声明。
	- for 声明。
	- switch-case 声明。
	- 函数定义声明。


---
### 1.2.3 算术表达式的求值过程

**第一步：将普通算术表达式（通常是中缀形式），变换为算术表达式（后缀形式）。**
1. 创建一个空的栈，用于存储操作符。
2. 从左到右扫描中缀表达式的每个元素。
3. 如果当前元素是操作数，则直接输出到逆波兰表达式中。
4. 如果当前元素是操作符，则进行如下操作：
    - 如果该操作符为左括号 “(”，则将其压入栈中。
    - 如果该操作符为右括号 “)”，则将栈中的操作符弹出并输出，直到遇到左括号为止。
    - 如果该操作符为其他操作符，则根据其优先级和结合性，依次将栈中比它**优先级高或等于它的操作符弹出并输出**，然后将该操作符压入栈中。
5. 当中缀表达式扫描完毕后，如果栈中还有操作符，则依次弹出并输出。

*以下是一个实例，将中缀 `"a+b*(c+d/e)"` 转化为后缀表达式的过程如下：*

| 中缀表达式 | 操作   | 栈         | 后缀表达式             |
| ----- | ---- | --------- | ----------------- |
| a     | 输出   | 空         | a                 |
| +     | 压栈   | +         | a                 |
| b     | 输出   | +         | a b               |
| *     | 压栈   | + *       | a b               |
| (     | 压栈   | + * (     | a b               |
| c     | 输出   | + * (     | a b c             |
| +     | 压栈   | + *（ +    | a b c             |
| d     | 输出   | + * ( +   | a b c d           |
| /     | 压栈   | + * ( + / | a b c d           |
| e     | 输出   | + * ( + / | a b c d e         |
| )     | 弹栈输出 | + *       | a b c d e /       |
| 结束    | 弹栈输出 | 空         | a b c d e / + * + |

**第二步：依托栈，计算算术表达式的值。**
1. 创建一个空栈，用于存储数字。
2. 从左到右扫描后缀表达式的每个元素。
3. 如果当前元素是数字或名字，则将其压入栈中。
4. 如果当前元素是操作符，则依次弹出栈顶的两个数字或名字，进行名字的求值，和值的运算，并将结果压入栈中。
5. 当后缀表达式扫描完毕后，栈中的唯一元素就是表达式的最终结果。

*以下是一个示例，计算后缀表达式 “`3 4 2 * 1 5 - 2 ^ / +`”：*

| 后缀表达式 | 操作      | 栈        |
| ----- | ------- | -------- |
| 3     | 压栈      | 3        |
| 4     | 压栈      | 3 4      |
| 2     | 压栈      | 3 4 2    |
| *     | 弹栈计算并压栈 | 3 8      |
| 1     | 压栈      | 3 8 1    |
| 5     | 压栈      | 3 8 1 5  |
| -     | 弹栈计算并压栈 | 3 8 -4   |
| 2     | 压栈      | 3 8 -4 2 |
| ^     | 弹栈计算并压栈 | 3 8 16   |
| /     | 弹栈计算并压栈 | 0.1875   |
| +     | 弹栈计算并压栈 | 3.1875   |

---

### 1.2.4 基于算术表达式构建二叉树
**表达式二叉树的作用是方便快速获取相同算术表达式的前缀、中缀、后缀形式。**
- 对表达式二叉树进行前序遍历，对应获得前缀表达式。
- 对表达式二叉树进行中序遍历，对应获得中缀表达式。
- 对表达式二叉树进行后序遍历，对应获得后缀表达式。

---

**基于算术表达式构建二叉树，应先获得后缀式，然后按照规则构建。**
1. 将算术表达式转化为**后缀表达式。**
2. 从左到右扫描后缀表达式的每个元素：
    - 如果当前元素是操作数，则创建一个**只包含该操作数的节点**，并将该节点压入栈中。
    - 如果当前元素是操作符，则创建一个只包含该操作符的节点，并从栈中弹出两个节点作为其左右子节点，再将该节点压入栈中。
3. 最后栈中唯一的节点即为根节点，整个树的结构已经建立完成。

*以下是一个示例，将算术表达式 `"a+b*(c+d/e)"` 转化为二叉树的过程如下：
1. 将算术表达式转化为后缀表达式：`abcde/+*+`
2. 从左到右扫描后缀表达式的每个元素：
    - a：创建一个只包含 a 的节点，并将该节点压入栈中。
    - b：创建一个只包含 b 的节点，并将该节点压入栈中。
    - c：创建一个只包含 c 的节点，并将该节点压入栈中。
    - d：创建一个只包含 d 的节点，并将该节点压入栈中。
    - e：创建一个只包含 e 的节点，并将该节点压入栈中。
    - /：创建一个只包含 / 的节点，并从栈中弹出两个节点 e 和 d 作为其左右子节点，再将该节点压入栈中。
    - +：创建一个只包含 + 的节点，并从栈中弹出两个节点 c 和 / 作为其左右子节点，再将该节点压入栈中。
    - * ：创建一个只包含 * 的节点，并从栈中弹出两个节点 b 和 + 作为其左右子节点，再将该节点压入栈中。
    - +：创建一个只包含 + 的节点，并从栈中弹出两个节点 a 和 * 作为其左右子节点，再将该节点压入栈中。
3. 根节点为最后剩余在栈中的节点 +。

---

### 1.2.5 函数调用表达式的求值过程
- 求解函数调用表达式，就是要递归求解Operators、Operands。
  - 递归求解Operators和Operands的值，顺序按照：先从左到右求解Operands，最后求解Operator。
  - 创建新local frame，绑定Operands值到函数签名中的formal parameters。
  - 执行函数体，将值向上递归返回，销毁当前local frame。

**求解mul(add(4, mul(4,6)), add(3,5))的例子**
  - 求解add(4, mul(4,6))，由于也是function call expression，所以进入下一层递归，最后会得到28：
    - 求解4，得到4。
    - 求解mul(4, 6)，由于也是function call expression，所以进入下一层递归：
      - 求解4，得到4。
      - 求解6，得到6。
      - 求解mul，得到mul对应的函数：def mul(a, b)
      - 创建名为mul的local frame，绑定4, 6到a, b。
      - 执行mul的函数体，返回24，销毁名为mul的local frame。
    - 求解add，得到add对应的函数：def add(a, b)
    - 创建名为add的local frame，绑定4，24到a，b。
    - 执行add的函数体，返回28，销毁名为add的local frame。
  - 求解add(3,5)，由于也是function call expression，所以进入下一层递归，最后会得到8：
    - 求解3，得到3。
    - 求解5，得到5。
    - 求解add，得到add对应的函数：def add(a, b)。
    - 创建名为add的local frame，绑定3，5到a，b。
    - 执行add的函数体，返回8，销毁名为add的local frame。
  - 求解mul，得到mul对应的函数：def mul(a, b)
  - 创建名为mul的local frame，绑定28, 8到a, b。
  - 执行mul的函数体，返回224，销毁名为mul的local frame。
  - global frame得到mul(add(4, mul(4,6)), add(3,5))的返回值224。
  - 结束。

**函数调用表达式的求解过程，可以画成一棵树**
![Expression Tree](image-1.png)

---

## 1.3 算法设计
**计算机算法与算法设计的核心在于高效地解决问题，即通过设计一系列明确、有限的步骤（算法），在给定约束（如时间、空间）下，优化地完成特定任务。**
1. **问题抽象与建模**：将现实问题转化为计算机可处理的数学或逻辑模型，明确输入、输出和约束。
2. **计算效率**：追求时间复杂度和空间复杂度的优化，确保算法在合理时间内完成任务。
3. **正确性与可靠性**：算法必须始终产生正确的结果，且能处理边界情况和异常输入。
4. **通用性与可扩展性**：设计算法时考虑其适用范围和对未来需求的适应性。


### 1.3.1 迭代和递归
**迭代和递归，是实现算法设计的两种基本策略，提供了两种基础的算法设计构型。**

1. **迭代：** 迭代通过循环结构重复执行一组操作，逐步逼近问题的解。它通常用于问题可以被分解为重复的、顺序执行的步骤时。
	-  **代码特征：**
		- 从当前问题最简单的CASE开始，使用for, while循环，不断探索问题的解空间，直至获得最终答案。
	- **状态变量的维护：**
		- 算法执行过程中，在for, while循环体内，在合适的时刻、维护有用的状态变量，用于标记当前解空间的搜索进度，判断当前循环的继续与否。
	- **应用场景：**
		- 可以按线性顺序求解的问题：BFS广度搜索、选择排序。
		- 性能敏感场景：最长公共子序列。

2. **递归：** 递归通过将问题分解为更小的子问题，调用自身来解决问题。它适用于问题具有自相似性（即大问题可分解为与原问题结构相同的子问题）。
	- **代码特征：**
		- 用递归策略设计的函数，必定直接，或间接地调用函数自身。
		- 将实现递归算法的代码看作整体，可分为"分治"和"组合"，两部分。
			- "分治"：设计拆分大问题的逻辑，使用多个条件判断，将大问题拆分成小问题。在尝试解决当前小问题的同时，利用自身调用，将剩余大问题传递到递归栈的下一层，形成top-down顺序的递归调用栈。并单纯地信任 **“剩余问题可以被函数自身调用（迭代）正确地解决”** （即a recursive leap of faith）。
			- "组合"：按照递归栈的顺序，从递归栈的最底层，down-top地，将小问题的答案，逐步组合成更大一号问题的答案，直至组合出最终答案。
	- **状态变量的维护：** 
		- 算法执行过程中，状态变量隐式存储在函数调用栈结构之间。
			- *备注：每个新的函数调用，会在environment创建新的local frame，解释器会按照栈结构维护local frames。*
	- **应用场景：**
		- 典型递归结构的数据：树算法、图算法。
		- 可以分而治之的问题：快速排序、N皇后问题。
		- 递归形式的数学问题：number partitions、斐波那契数列、阶乘数列。


**Normal Recursion, Mutual Recursion和Tree Recursion：重点在于递归函数内部，调用递归的方式、次数不同，因此适合处理问题场景不同。**
- Normal Recursion：
	- 递归函数每执行一次，最多仅进行一次递归调用。
	- 使用场景：简单的、需要使用递归的场景。
- Mutual Recursion：
	- 拥有两个递归函数，且它们之间互相调用。
	- 使用场景：mutual recursion的递归调用栈更复杂，可以存储更多的状态，可以应对相对复杂的问题。
- Tree Recursion：
	- 递归函数每执行一次，进行两次或两次以上的递归调用。
	- 使用场景：每次可以执行多个递归，适合更复杂的解空间搜索问题，相当于用递归的方法，降低复杂问题的求解难度。

**递归代码范例**
1. 确定好的"问题分治策略"，接下来，做两个重要事情。
2. 定义一个或多个base case判断语句，判断和捕获最简单子问题，提供递归的出口。*例如：求解n!问题，最简单子问题就是1的阶乘。*
3. Base CASE之后，是一个或多个带有迭代函数调用表达式的声明语句。
	1. 迭代调用表达式的传入参数，应当体现具体的“分治”策略（即问题大拆小的策略）。
	2. 迭代调用的声明语句，应体现"组合"答案的逻辑，可以是简单相加，也可以是list存储，也可以是直接打印。*如CASE ONE 第52行，CASE TWO第81行，CASE THREE第133 134行*


CASE ONE：count_partition函数，计算给定n,m时，number partition一共有多少种。
![[Pasted image 20250514112951.png|600]]

CASE TWO：fib_tree函数，生成给定n时的斐波那契数树。
![[Pasted image 20250514113555.png|500]]

CASE THREE: partition_tree函数，生成给定n,m时，number partition的所有可能结果树。
![[Pasted image 20250514113817.png|500]]

CASE FOUR：sum_digits，将一个正整数n的所有数字相加的和。
![[Pasted image 20250514163304.png|700]]

CASE FIVE: is_even, is_odd，判断一个正整数N是否是EVEN的。 
![[Pasted image 20250514163425.png]]


**迭代代码范例**
1. 函数体的开头，创建多个用于维护状态的变量。
2. 使用for或者while循环，迭代搜索解空间、构建最终解。
3. 在for和while循环内，更新维护状态变量。

CASE ONE: fact_iter，通过迭代的方式，计算n!的值。
![[Pasted image 20250520094638.png|600]]

